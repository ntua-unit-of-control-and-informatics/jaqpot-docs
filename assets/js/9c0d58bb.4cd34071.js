"use strict";(self.webpackChunkeuclia_docs=self.webpackChunkeuclia_docs||[]).push([[647],{3905:(e,a,t)=>{t.d(a,{Zo:()=>m,kt:()=>f});var r=t(7294);function i(e,a,t){return a in e?Object.defineProperty(e,a,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[a]=t,e}function n(e,a){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);a&&(r=r.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),t.push.apply(t,r)}return t}function l(e){for(var a=1;a<arguments.length;a++){var t=null!=arguments[a]?arguments[a]:{};a%2?n(Object(t),!0).forEach((function(a){i(e,a,t[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):n(Object(t)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))}))}return e}function o(e,a){if(null==e)return{};var t,r,i=function(e,a){if(null==e)return{};var t,r,i={},n=Object.keys(e);for(r=0;r<n.length;r++)t=n[r],a.indexOf(t)>=0||(i[t]=e[t]);return i}(e,a);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);for(r=0;r<n.length;r++)t=n[r],a.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var s=r.createContext({}),p=function(e){var a=r.useContext(s),t=a;return e&&(t="function"==typeof e?e(a):l(l({},a),e)),t},m=function(e){var a=p(e.components);return r.createElement(s.Provider,{value:a},e.children)},u="mdxType",c={inlineCode:"code",wrapper:function(e){var a=e.children;return r.createElement(r.Fragment,{},a)}},d=r.forwardRef((function(e,a){var t=e.components,i=e.mdxType,n=e.originalType,s=e.parentName,m=o(e,["components","mdxType","originalType","parentName"]),u=p(t),d=i,f=u["".concat(s,".").concat(d)]||u[d]||c[d]||n;return t?r.createElement(f,l(l({ref:a},m),{},{components:t})):r.createElement(f,l({ref:a},m))}));function f(e,a){var t=arguments,i=a&&a.mdxType;if("string"==typeof e||i){var n=t.length,l=new Array(n);l[0]=d;var o={};for(var s in a)hasOwnProperty.call(a,s)&&(o[s]=a[s]);o.originalType=e,o[u]="string"==typeof e?e:i,l[1]=o;for(var p=2;p<n;p++)l[p]=t[p];return r.createElement.apply(null,l)}return r.createElement.apply(null,t)}d.displayName="MDXCreateElement"},9055:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>s,contentTitle:()=>l,default:()=>c,frontMatter:()=>n,metadata:()=>o,toc:()=>p});var r=t(7462),i=(t(7294),t(3905));const n={id:"Molecular_descriptors",title:"Molecular",sidebar_label:"Molecular_descriptors",keywords:["fingerprints","descriptors","featurizer","featurize"]},l=void 0,o={unversionedId:"Molecular_descriptors",id:"Molecular_descriptors",title:"Molecular",description:"Main Import",source:"@site/docs/Molecular_descriptors.md",sourceDirName:".",slug:"/Molecular_descriptors",permalink:"/jaqpot-docs/docs/Molecular_descriptors",draft:!1,tags:[],version:"current",frontMatter:{id:"Molecular_descriptors",title:"Molecular",sidebar_label:"Molecular_descriptors",keywords:["fingerprints","descriptors","featurizer","featurize"]},sidebar:"someSidebar",previous:{title:"Jaqpot Services",permalink:"/jaqpot-docs/docs/jaqpot"},next:{title:"Molecular_datasets",permalink:"/jaqpot-docs/docs/Molecular_datasets"}},s={},p=[{value:"Main Import",id:"main-import",level:2},{value:"Main Reference",id:"main-reference",level:2},{value:"MACCSKeysFingerprint",id:"maccskeysfingerprint",level:3},{value:"CLASS: MACCSKeysFingerprint()",id:"class-maccskeysfingerprint",level:4},{value:"Example:",id:"example",level:5},{value:"RDKitDescriptors",id:"rdkitdescriptors",level:3},{value:"CLASS: RDKitDescriptors(use_fragment=True, ipc_avg=True)",id:"class-rdkitdescriptorsuse_fragmenttrue-ipc_avgtrue",level:4},{value:"Parameters",id:"parameters",level:4},{value:"Example",id:"example-1",level:5},{value:"PubChemFingerprint",id:"pubchemfingerprint",level:3},{value:"CLASS: PubChemFingerprint()",id:"class-pubchemfingerprint",level:4},{value:"Example",id:"example-2",level:6},{value:"MordredDescriptors",id:"mordreddescriptors",level:3},{value:"CLASS: MordredDescriptors(ignore_3D = True)",id:"class-mordreddescriptorsignore_3d--true",level:4},{value:"Parameters",id:"parameters-1",level:4},{value:"Example",id:"example-3",level:5},{value:"TopologicalFingerprint",id:"topologicalfingerprint",level:3},{value:"CLASS: TopologicalFingerprint(radius=2,size=2048,chiral=False,bonds=True,features=False,sparse=False,smiles=False)",id:"class-topologicalfingerprintradius2size2048chiralfalsebondstruefeaturesfalsesparsefalsesmilesfalse",level:4},{value:"Parameters",id:"parameters-2",level:4},{value:"Example",id:"example-4",level:5},{value:"SmilesToImage",id:"smilestoimage",level:3},{value:"CLASS: SmilesToImage(img_size=80, res=0.5, max_len=250, img_spec=&quot;std&quot;)",id:"class-smilestoimageimg_size80-res05-max_len250-img_specstd",level:4},{value:"Parameters",id:"parameters-3",level:4},{value:"Example",id:"example-5",level:5},{value:"SmilesToSeq",id:"smilestoseq",level:3},{value:"CLASS: SmilesToSeq(char_to_idx, max_len=250,pad_len)",id:"class-smilestoseqchar_to_idx-max_len250pad_len",level:4},{value:"Parameters",id:"parameters-4",level:4},{value:"Example",id:"example-6",level:5},{value:"OneHotSequence",id:"onehotsequence",level:3},{value:"CLASS: OneHotSequence(charset = ZINC_CHARSET, max_length = 100)",id:"class-onehotsequencecharset--zinc_charset-max_length--100",level:4},{value:"Parameters",id:"parameters-5",level:4},{value:"Example",id:"example-7",level:5},{value:"MolGraphConvFeaturizer",id:"molgraphconvfeaturizer",level:3},{value:"CLASS : MolGraphConvFeaturizer(use_edges=False, use_chirality=False, use_partial_charge=False)",id:"class--molgraphconvfeaturizeruse_edgesfalse-use_chiralityfalse-use_partial_chargefalse",level:4},{value:"Parameters",id:"parameters-6",level:4},{value:"Example",id:"example-8",level:5},{value:"PagtnMolGraphFeaturizer",id:"pagtnmolgraphfeaturizer",level:3},{value:"CLASS: PagtnMolGraphFeaturizer(max_length=5)",id:"class-pagtnmolgraphfeaturizermax_length5",level:4},{value:"Parameters",id:"parameters-7",level:4},{value:"Example",id:"example-9",level:5},{value:"TorchMolGraphConvFeaturizer",id:"torchmolgraphconvfeaturizer",level:3},{value:"CLASS: TorchMolGraphConvFeaturizer(use_edges=False, use_chirality=False, use_partial_charge=False)",id:"class-torchmolgraphconvfeaturizeruse_edgesfalse-use_chiralityfalse-use_partial_chargefalse",level:4},{value:"Parameters",id:"parameters-8",level:4},{value:"Example",id:"example-10",level:5},{value:"AttentiveFPFeaturizer",id:"attentivefpfeaturizer",level:3},{value:"AttentiveFPFeaturizer(use_loops=False)",id:"attentivefpfeaturizeruse_loopsfalse",level:4},{value:"Parameters",id:"parameters-9",level:4},{value:"Example",id:"example-11",level:5},{value:"CoulombMatrix",id:"coulombmatrix",level:3},{value:"CLASS: CoulombMatrix(max_atoms, remove_hydrogens=False, randomize=False, upper_tri=False, n_samples=1,seed=None)",id:"class-coulombmatrixmax_atoms-remove_hydrogensfalse-randomizefalse-upper_trifalse-n_samples1seednone",level:4},{value:"Parameters",id:"parameters-10",level:4},{value:"Example",id:"example-12",level:5},{value:"CoulombMatrixEig",id:"coulombmatrixeig",level:3},{value:"CLASS: CoulombMatrixEig(max_atoms, remove_hydrogens=False, randomize=False, upper_tri=False, n_samples=1,seed=None)",id:"class-coulombmatrixeigmax_atoms-remove_hydrogensfalse-randomizefalse-upper_trifalse-n_samples1seednone",level:4},{value:"Parameters",id:"parameters-11",level:4},{value:"Example",id:"example-13",level:5},{value:"MolGanFeaturizer",id:"molganfeaturizer",level:3},{value:"MolGanFeaturizer(max_atom_count=9,kekulize=True,sanitize=False,bond_labels=None,atom_labels=None)",id:"molganfeaturizermax_atom_count9kekulizetruesanitizefalsebond_labelsnoneatom_labelsnone",level:4},{value:"Parameters",id:"parameters-12",level:4},{value:"Example",id:"example-14",level:5}],m={toc:p},u="wrapper";function c(e){let{components:a,...t}=e;return(0,i.kt)(u,(0,r.Z)({},m,t,{components:a,mdxType:"MDXLayout"}),(0,i.kt)("h2",{id:"main-import"},"Main Import"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"import jaqpotpy.descriptors.molecular")),(0,i.kt)("h2",{id:"main-reference"},"Main Reference"),(0,i.kt)("p",null,"Code and descriptors are based on open-source DeepChem Library:\n",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("a",{parentName:"strong",href:"https://github.com/deepchem/deepchem"},"https://github.com/deepchem/deepchem"))),(0,i.kt)("h3",{id:"maccskeysfingerprint"},"MACCSKeysFingerprint"),(0,i.kt)("h4",{id:"class-maccskeysfingerprint"},"CLASS: MACCSKeysFingerprint()"),(0,i.kt)("p",null,"Class for computing chemical fingerprints for molecules using MACCS (Molecular ACCess System). For each molecule it generates a total of 167 different fingerprints. For a list of molecules in SMILES format use ",(0,i.kt)("inlineCode",{parentName:"p"},".featurize(list)")," to obtain the fingerprints.",(0,i.kt)("br",{parentName:"p"}),"\n",(0,i.kt)("strong",{parentName:"p"},"","[1]"," ",(0,i.kt)("a",{parentName:"strong",href:"https://github.com/rdkit/rdkit/blob/master/rdkit/Chem/MACCSkeys.py"},"https://github.com/rdkit/rdkit/blob/master/rdkit/Chem/MACCSkeys.py")),(0,i.kt)("br",{parentName:"p"}),"\n",(0,i.kt)("strong",{parentName:"p"},"","[2]",' Durant, Joseph L.,   et al. "Reoptimization of MDL keys for use in drug discovery."\nJournal of chemical information and computer sciences 42.6 (2002): 1273-1280.')),(0,i.kt)("h5",{id:"example"},"Example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"from jaqpotpy.descriptors.molecular import MACCSKeysFingerprint\n\nsmiles = ['c1cc(O)ccc1', 'O=Cc1ccc(O)c(OC)c1']\nfeaturizer = MACCSKeysFingerprint()\n# Create numpy array of features\nfeatures = featurizer.featurize(smiles)\n# Create dataframe of features\nfeatures_df = featurizer.featurize_dataframe(smiles)\n")),(0,i.kt)("h3",{id:"rdkitdescriptors"},"RDKitDescriptors"),(0,i.kt)("h4",{id:"class-rdkitdescriptorsuse_fragmenttrue-ipc_avgtrue"},"CLASS: RDKitDescriptors(use_fragment=True, ipc_avg=True)"),(0,i.kt)("p",null,"This class computes a list of chemical descriptors like molecular weight, number of valence electrons, maximum and minimum partial charge, etc using RDKit library. For each molecule it calculates a total of 208 different features. For a list of molecules in SMILES format use ",(0,i.kt)("inlineCode",{parentName:"p"},".featurize(list)")," to obtain the features. RDkit package must be installed.",(0,i.kt)("br",{parentName:"p"}),"\n",(0,i.kt)("strong",{parentName:"p"},"","[1]"," ",(0,i.kt)("a",{parentName:"strong",href:"https://www.rdkit.org/"},"https://www.rdkit.org/"))),(0,i.kt)("h4",{id:"parameters"},"Parameters"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"use_fragment(bool,optional)")," : If fragment binary descriptors are included."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ipc_avg(bool,optional)")," : If IPC descriptor calculates with rdkit avg=True option.")),(0,i.kt)("h5",{id:"example-1"},"Example"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"from jaqpotpy.descriptors.molecular import RDKitDescriptors\n\nsmiles = ['c1cc(O)ccc1', 'O=Cc1ccc(O)c(OC)c1']\nfeaturizer = RDKitDescriptors()\nfeatures = featurizer.featurize(smiles)\n")),(0,i.kt)("h3",{id:"pubchemfingerprint"},"PubChemFingerprint"),(0,i.kt)("h4",{id:"class-pubchemfingerprint"},"CLASS: PubChemFingerprint()"),(0,i.kt)("p",null,"Class for computing structural keys for molecules using PubChem. For each molecule it calculates a total of 881 different fingerprints. It is mainly used for similarity searching. For a list of molecules in SMILES format use ",(0,i.kt)("inlineCode",{parentName:"p"},".featurize(list)")," to obtain the features. PubChemPy use REST API to get the fingerprint, so you need the internet access.",(0,i.kt)("br",{parentName:"p"}),"\n",(0,i.kt)("strong",{parentName:"p"},"","[1]"," ",(0,i.kt)("a",{parentName:"strong",href:"https://web.cse.ohio-state.edu/~zhang.10631/bak/drugreposition/list_fingerprints.pdf"},"https://web.cse.ohio-state.edu/~zhang.10631/bak/drugreposition/list_fingerprints.pdf"))),(0,i.kt)("h6",{id:"example-2"},"Example"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"from jaqpotpy.descriptors.molecular import PubChemFingerprint\n\nsmiles = ['c1cc(O)ccc1', 'O=Cc1ccc(O)c(OC)c1']\nfeaturizer = PubChemFingerprint()\nfeatures = featurizer.featurize(smiles)\n")),(0,i.kt)("h3",{id:"mordreddescriptors"},"MordredDescriptors"),(0,i.kt)("h4",{id:"class-mordreddescriptorsignore_3d--true"},"CLASS: MordredDescriptors(ignore_3D = True)"),(0,i.kt)("p",null,"Class for computing chemical descriptors for molecules using Mordred Descriptors. For each molecule it calculates a total of 1613 features. For a list of molecules in SMILES format use ",(0,i.kt)("inlineCode",{parentName:"p"},".featurize(list)")," to obtain the features. This class requires Mordred to be installed.",(0,i.kt)("br",{parentName:"p"}),"\n",(0,i.kt)("strong",{parentName:"p"},"","[1]"," ",(0,i.kt)("a",{parentName:"strong",href:"http://mordred-descriptor.github.io/documentation/master/descriptors.html"},"http://mordred-descriptor.github.io/documentation/master/descriptors.html"))," "),(0,i.kt)("h4",{id:"parameters-1"},"Parameters"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ignore_3D(bool,optional)")," : If 3D information is used for descriptor calculation.")),(0,i.kt)("h5",{id:"example-3"},"Example"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"from jaqpotpy.descriptors.molecular import MordredDescriptors\n\nsmiles = ['c1cc(O)ccc1', 'O=Cc1ccc(O)c(OC)c1']\nfeaturizer = MordredDescriptors()\nfeatures = featurizer.featurize(smiles)\n")),(0,i.kt)("h3",{id:"topologicalfingerprint"},"TopologicalFingerprint"),(0,i.kt)("h4",{id:"class-topologicalfingerprintradius2size2048chiralfalsebondstruefeaturesfalsesparsefalsesmilesfalse"},"CLASS: TopologicalFingerprint(radius=2,size=2048,chiral=False,bonds=True,features=False,sparse=False,smiles=False)"),(0,i.kt)("p",null,"Class for computing Extended Connectivity Circular Fingerprints. Those fingerprints compute a bag-of-words style representation of a molecule by breaking it into local neighborhoods and hashing into a bit vector of the specified size. It is used specifically for structure-activity modelling molecular Circular (Morgan) fingerprints. For each molecule it calculates a total of 2048 different fingerprints. For a list of molecules in SMILES format use ",(0,i.kt)("inlineCode",{parentName:"p"},".featurize(list)")," to obtain the features. Rdkit is required to be installed.",(0,i.kt)("br",{parentName:"p"}),"\n",(0,i.kt)("strong",{parentName:"p"},"","[1]"," ",(0,i.kt)("a",{parentName:"strong",href:"https://pubmed.ncbi.nlm.nih.gov/20426451/"},"https://pubmed.ncbi.nlm.nih.gov/20426451/"))),(0,i.kt)("h4",{id:"parameters-2"},"Parameters"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"radius(int,optional)"),": Specify fingerprint radius."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"size(int,optional)"),": Length of features."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"chiral(bool,optional)"),": If chirality is used for fingerprint generation."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"bonds(bool,optional)"),": If bonds are used for fingerprint generation."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"features(bool,optional)"),": If feature information is used instead of atom information."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"sparse(bool,optional)"),": Returns dict with sparse fingerprint."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"smiles(bool,optional)"),": Calculates SMILES strings for fragment IDs.")),(0,i.kt)("h5",{id:"example-4"},"Example"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"from jaqpotpy.descriptors.molecular import TopologicalFingerprint\n\nsmiles = ['c1cc(O)ccc1', 'O=Cc1ccc(O)c(OC)c1']\nfeaturizer = TopologicalFingerprint()\nfeatures = featurizer.featurize(smiles)\n")),(0,i.kt)("h3",{id:"smilestoimage"},"SmilesToImage"),(0,i.kt)("h4",{id:"class-smilestoimageimg_size80-res05-max_len250-img_specstd"},'CLASS: SmilesToImage(img_size=80, res=0.5, max_len=250, img_spec="std")'),(0,i.kt)("p",null,"Class for converting a SMILES string to an image tensor. The default size of for the image is 80 x 80. Two image modes are currently supported - std & engd. std is the gray scale specification, with atomic numbers as pixel values for atom positions and a constant value of 2 for bond positions. engd is a 4-channel specification, which uses atom properties like hybridization, valency, charges in addition to atomic number. Bond type is also used for the bonds. The coordinates of all atoms are computed, and lines are drawn between atoms to indicate bonds. For the respective channels, the atom and bond positions are set to the property values as mentioned in the paper below.",(0,i.kt)("br",{parentName:"p"}),"\n",(0,i.kt)("strong",{parentName:"p"},"","[1]"," ",(0,i.kt)("a",{parentName:"strong",href:"https://dl.acm.org/doi/10.1145/3219819.3219838"},"https://dl.acm.org/doi/10.1145/3219819.3219838"))),(0,i.kt)("h4",{id:"parameters-3"},"Parameters"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"img_size(int,optional)"),": Size of output tensor."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"res(float,optional)"),": Resolution of each pixel in Angstrom. "),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"max_len(int,optional)"),": Maximum length of input SMILES string."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"img_spec(str,optional)"),': Channel organization of the image tensor, ("std","engd").')),(0,i.kt)("h5",{id:"example-5"},"Example"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"from jaqpotpy.descriptors.molecular import SmilesToImage\n\nsmiles = ['c1cc(O)ccc1', 'O=Cc1ccc(O)c(OC)c1']\nfeaturizer = SmilesToImage()\nimages = featurizer.featurize(smiles)\n")),(0,i.kt)("h3",{id:"smilestoseq"},"SmilesToSeq"),(0,i.kt)("h4",{id:"class-smilestoseqchar_to_idx-max_len250pad_len"},"CLASS: SmilesToSeq(char_to_idx, max_len=250,pad_len)"),(0,i.kt)("p",null,"Class for converting a SMILES string into a sequence. Use ",(0,i.kt)("inlineCode",{parentName:"p"},".featurize")," to convert. SMILES strings smaller than a specified max length (max_len) are padded using the PAD token while those larger than the max length are not considered. Based on the paper, there is also the option to add extra padding (pad_len) on both sides of the string after length normalization. Using a character to index (char_to_idx) mapping, the SMILES characters are turned into indices and the resulting sequence of indices serves as the input for an embedding layer.",(0,i.kt)("br",{parentName:"p"}),"\n",(0,i.kt)("strong",{parentName:"p"},"","[1]"," ",(0,i.kt)("a",{parentName:"strong",href:"https://dl.acm.org/doi/10.1145/3219819.3219838"},"https://dl.acm.org/doi/10.1145/3219819.3219838"))),(0,i.kt)("h4",{id:"parameters-4"},"Parameters"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"char_to_idx(dict)"),": Dictionary containing character to index mapping for unique characters. Must be dict{str: int}."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"max_len(int,optional)"),": Maximum length of the SMILES string."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"pad_len(int,optional)"),": Amount of padding to add on either side of the SMILES seq.")),(0,i.kt)("h5",{id:"example-6"},"Example"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"from jaqpotpy.descriptors.molecular import SmilesToSeq\n\nsmiles = ['c1cc(O)ccc1', 'O=Cc1ccc(O)c(OC)c1']\nfeaturizer = SmilesToSeq(char_to_idx=....)\nsequence = featurizer.featurize(smiles)\n")),(0,i.kt)("h3",{id:"onehotsequence"},"OneHotSequence"),(0,i.kt)("h4",{id:"class-onehotsequencecharset--zinc_charset-max_length--100"},"CLASS: OneHotSequence(charset = ZINC_CHARSET, max_length = 100)"),(0,i.kt)("p",null,"Class for encoding any arbitrary string or molecule as a one-hot array. This featurizer encodes the characters within any given string as a one-hot array. It also works with RDKit molecules: it can convert RDKit molecules to SMILES strings and then one-hot encode the characters in said strings. Use ",(0,i.kt)("inlineCode",{parentName:"p"},".featurize")," to convert."),(0,i.kt)("h4",{id:"parameters-5"},"Parameters"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"charset(list,optional)")," : List of string where each string is length 1 and unique. Default is ZINC Charset."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"max_length(int,optional)")," : Max length of each string.")),(0,i.kt)("h5",{id:"example-7"},"Example"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"from jaqpotpy.descriptors.molecular import OneHotSequence\n\nsmiles = ['c1cc(O)ccc1', 'O=Cc1ccc(O)c(OC)c1']\nfeaturizer = OneHotSequence()\none_hot = featurizer.featurize(smiles)\n")),(0,i.kt)("h3",{id:"molgraphconvfeaturizer"},"MolGraphConvFeaturizer"),(0,i.kt)("h4",{id:"class--molgraphconvfeaturizeruse_edgesfalse-use_chiralityfalse-use_partial_chargefalse"},"CLASS : MolGraphConvFeaturizer(use_edges=False, use_chirality=False, use_partial_charge=False)"),(0,i.kt)("p",null,"Class for featurizing molecules for graph convolution. It calculates node(atom) features, adjacency matrix and edge(bond) features. Default feature representations are based on ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("a",{parentName:"strong",href:"https://arxiv.org/abs/1603.00856"},"https://arxiv.org/abs/1603.00856"))," paper. Node features are 30 and edge features are 11. Use ",(0,i.kt)("inlineCode",{parentName:"p"},".featurize")," method to obtain the features.",(0,i.kt)("br",{parentName:"p"}),"\n",(0,i.kt)("strong",{parentName:"p"},"","[1]",' Kearnes, Steven, et al. "Molecular graph convolutions: moving beyond fingerprints." Journal of computer-aided molecular design 30.8 (2016):595-608')),(0,i.kt)("h4",{id:"parameters-6"},"Parameters"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"use_edges(bool,optional)"),": If edge features are calculated."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"use_chirality(bool,optional)"),": If chirality is used in features."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"use_partial_charge(bool,optional)"),": If partial charge data are used.")),(0,i.kt)("h5",{id:"example-8"},"Example"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"from jaqpotpy.descriptors.molecular import MolGraphConvFeaturizer\n\nsmiles = ['c1cc(O)ccc1', 'O=Cc1ccc(O)c(OC)c1']\ngraphconv_featurizer = MolGraphConvFeaturizer(use_edges=True)\ngraphconv = graphconv_featurizer.featurize(smiles)\n\n# Numpy arrays of features\ngraphconv[0].node_features \ngraphconv[0].edge_features\ngraphconv[0].edge_index # Adjacency Matrix\n")),(0,i.kt)("h3",{id:"pagtnmolgraphfeaturizer"},"PagtnMolGraphFeaturizer"),(0,i.kt)("h4",{id:"class-pagtnmolgraphfeaturizermax_length5"},"CLASS: PagtnMolGraphFeaturizer(max_length=5)"),(0,i.kt)("p",null,"Class for featurizing molecules for graph convolution. It calculates node(atom) features, adjacency matrix and edge(bond) features. Default feature representations are based on PAGTN model ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("a",{parentName:"strong",href:"https://arxiv.org/abs/1905.12712"},"https://arxiv.org/abs/1905.12712")),". Node features are 94 and edge features are 42. Use ",(0,i.kt)("inlineCode",{parentName:"p"},".featurize")," method to obtain the features.",(0,i.kt)("br",{parentName:"p"}),"\n",(0,i.kt)("strong",{parentName:"p"},"","[1]",' Chen, Barzilay, Jaakkola "Path-Augmented Graph Transformer Network" 10.26434/chemrxiv.8214422.')),(0,i.kt)("h4",{id:"parameters-7"},"Parameters"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"max_length"),": Maximum distance up to which shortest paths must be considered. Paths shorter than max_length will be padded and longer will betruncated, default to 5.")),(0,i.kt)("h5",{id:"example-9"},"Example"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"from jaqpotpy.descriptors.molecular import PagtnMolGraphFeaturizer\n\nsmiles = ['c1cc(O)ccc1', 'O=Cc1ccc(O)c(OC)c1']\npagtn_featurizer = PagtnMolGraphFeaturizer()\npagtn = pagtn_featurizer.featurize(smiles)\n\npagtn[0].node_features\npagtn[0].edge_features\npagtn[0].edge_index\n")),(0,i.kt)("h3",{id:"torchmolgraphconvfeaturizer"},"TorchMolGraphConvFeaturizer"),(0,i.kt)("h4",{id:"class-torchmolgraphconvfeaturizeruse_edgesfalse-use_chiralityfalse-use_partial_chargefalse"},"CLASS: TorchMolGraphConvFeaturizer(use_edges=False, use_chirality=False, use_partial_charge=False)"),(0,i.kt)("p",null,"Class for featurizing molecules for graph convolution based on pytorch-geometric. It calculates node(atom) features, adjacency matrix and edge(bond) features. Default feature representations are based on ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("a",{parentName:"strong",href:"https://arxiv.org/abs/1603.00856"},"https://arxiv.org/abs/1603.00856")),". Node features are 30 and edge features are 11. Use ",(0,i.kt)("inlineCode",{parentName:"p"},".featurize")," method to obtain the features. Also the features are of type->torch.Tensor type. Requires numpy version <1.21 to be installed.. Doesn't work with newer versions."),(0,i.kt)("h4",{id:"parameters-8"},"Parameters"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"use_edges(bool,optional)"),": If edge features are calculated."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"use_chirality(bool,optional)"),": If chirality is used in features."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"use_partial_charge(bool,optional)"),": If partial charge data are used.")),(0,i.kt)("h5",{id:"example-10"},"Example"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"from jaqpotpy.descriptors.molecular import TorchMolGraphConvFeaturizer\n\nsmiles = ['c1cc(O)ccc1', 'O=Cc1ccc(O)c(OC)c1']\ntorch_featurizer = TorchMolGraphConvFeaturizer(use_edges=True)\ntorch_features = torch_featurizer.featurize(smiles)\n\ntorch_features[0][0][1] # Adjacency Matrix\ntorch_features[0][1][1] # Node Features\ntorch_features[0][2][1] # Edge Features\n")),(0,i.kt)("h3",{id:"attentivefpfeaturizer"},"AttentiveFPFeaturizer"),(0,i.kt)("h4",{id:"attentivefpfeaturizeruse_loopsfalse"},"AttentiveFPFeaturizer(use_loops=False)"),(0,i.kt)("p",null,"Class for featurizing molecules for  Attentive FP GNNs convolution paper ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("a",{parentName:"strong",href:"https://pubmed.ncbi.nlm.nih.gov/31408336/"},"https://pubmed.ncbi.nlm.nih.gov/31408336/"))," . It calculates node(atom) features, adjacency matrix and edge(bond) features. Node features are 39 and edge features are 10. Use ",(0,i.kt)("inlineCode",{parentName:"p"},".featurize")," method to obtain the features.",(0,i.kt)("br",{parentName:"p"}),"\n",(0,i.kt)("strong",{parentName:"p"},"","[1]"," Xiong Z, Wang D, Liu X, Zhong F, Wan X, Li X, Li Z, Luo X, Chen K, Jiang H, Zheng M. Pushing the Boundaries of Molecular Representation for Drug Discovery with the Graph Attention Mechanism. J Med Chem. 2020 Aug 27;63(16):8749-8760. doi: 10.1021/acs.jmedchem.9b00959. Epub 2019 Aug 27. PMID: 31408336.")),(0,i.kt)("h4",{id:"parameters-9"},"Parameters"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"use_loops(bool,optional)"),": If self loops are added.")),(0,i.kt)("h5",{id:"example-11"},"Example"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"from jaqpotpy.descriptors.molecular import AttentiveFPFeaturizer\n\nsmiles = ['c1cc(O)ccc1', 'O=Cc1ccc(O)c(OC)c1']\natt_featurizer = AttentiveFPFeaturizer()\natt_features = att_featurizer.featurize(smiles)\n\natt_features[0].edge_index\natt_features[0].node_features\natt_features[0].edge_features\n")),(0,i.kt)("h3",{id:"coulombmatrix"},"CoulombMatrix"),(0,i.kt)("h4",{id:"class-coulombmatrixmax_atoms-remove_hydrogensfalse-randomizefalse-upper_trifalse-n_samples1seednone"},"CLASS: CoulombMatrix(max_atoms, remove_hydrogens=False, randomize=False, upper_tri=False, n_samples=1,seed=None)"),(0,i.kt)("p",null,"Class to calculate Coulomb matrices for molecules. For N atoms the coulomb matrix is N x N based on the method from the paper ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("a",{parentName:"strong",href:"https://proceedings.neurips.cc/paper_files/paper/2012/hash/115f89503138416a242f40fb7d7f338e-Abstract.html"},"https://proceedings.neurips.cc/paper_files/paper/2012/hash/115f89503138416a242f40fb7d7f338e-Abstract.html")),". This class requires RDKit to be installed Use ",(0,i.kt)("inlineCode",{parentName:"p"},".featurize")," method to calculate the matrix.",(0,i.kt)("br",{parentName:"p"}),"\n",(0,i.kt)("strong",{parentName:"p"},"","[1]",' Montavon, Gr\xe9goire, et al. "Learning invariant representations of molecules for atomization energy prediction." Advances in neural information processing systems. 2012.')),(0,i.kt)("h4",{id:"parameters-10"},"Parameters"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"max_atoms(int)"),": Maximum number of atoms to featurize (Dimensions of the Matrix)."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"remove_hydrogens(bool,optional)"),": If hydrogens are removed before processing them."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"randomize(bool,optional)"),": If matrix are randomized."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"upper_tri(bool,optional)"),": If only upper triangle of Coulomb matrix is generated."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"n_samples(bool,optional)"),": Number of samples to draw if randomize=True."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"seed"),": Generate random seed for deterministic results.")),(0,i.kt)("h5",{id:"example-12"},"Example"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"from jaqpotpy.descriptors.molecular import CoulombMatrix\n\nsmiles = ['c1cc(O)ccc1', 'O=Cc1ccc(O)c(OC)c1']\ncm_featurizer = CoulombMatrix(max_atoms=20)\n\ncm_features = cm_featurizer.featurize(smiles)\n\n# Coulomb Matrix\ncm_features[0]\n")),(0,i.kt)("h3",{id:"coulombmatrixeig"},"CoulombMatrixEig"),(0,i.kt)("h4",{id:"class-coulombmatrixeigmax_atoms-remove_hydrogensfalse-randomizefalse-upper_trifalse-n_samples1seednone"},"CLASS: CoulombMatrixEig(max_atoms, remove_hydrogens=False, randomize=False, upper_tri=False, n_samples=1,seed=None)"),(0,i.kt)("p",null,"Class to calculate eigenvalues of Coulomb matrices for molecules. Use ",(0,i.kt)("inlineCode",{parentName:"p"},".featurize")," method to calculate the matrix.",(0,i.kt)("br",{parentName:"p"}),"\n",(0,i.kt)("strong",{parentName:"p"},"","[1]",' Montavon, Gr\xe9goire, et al. "Learning invariant representations of molecules for atomization energy prediction." Advances in neural information processing systems. 2012.')),(0,i.kt)("h4",{id:"parameters-11"},"Parameters"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"max_atoms(int)"),": Maximum number of atoms to featurize(Dimensions of the Matrix)."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"remove_hydrogens(bool,optional)"),": If hydrogens are removed before processing them."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"randomize(bool,optional)"),": If matrix are randomized."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"upper_tri(bool,optional)"),": If only upper triangle of Coulomb matrix is generated."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"n_samples(bool,optional)"),": Number of samples to draw if randomize=True."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"seed"),": Generate random seed.")),(0,i.kt)("h5",{id:"example-13"},"Example"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"from jaqpotpy.descriptors.molecular import CoulombMatrixEig\n\nsmiles = ['c1cc(O)ccc1', 'O=Cc1ccc(O)c(OC)c1']\neig_featurizer = CoulombMatrixEig(max_atoms=20)\n\neig_features = eig_featurizer.featurize(smiles)\n\n# EigenvaluesCoulomb Matrix\neig_features[0]\n")),(0,i.kt)("h3",{id:"molganfeaturizer"},"MolGanFeaturizer"),(0,i.kt)("h4",{id:"molganfeaturizermax_atom_count9kekulizetruesanitizefalsebond_labelsnoneatom_labelsnone"},"MolGanFeaturizer(max_atom_count=9,kekulize=True,sanitize=False,bond_labels=None,atom_labels=None)"),(0,i.kt)("p",null,"Class to feauturize molecules for de-novo molecular generation based on ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("a",{parentName:"strong",href:"https://arxiv.org/abs/1805.11973"},"https://arxiv.org/abs/1805.11973")),". Use ",(0,i.kt)("inlineCode",{parentName:"p"},".featurize")," method to get the features."),(0,i.kt)("h4",{id:"parameters-12"},"Parameters"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"max_atom_count"),": Maximum number of atoms for adjacency matrix creation."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"kekulize"),": If molecules are kekulized."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"bond_labels"),": List of bond types for adjacency matrix creation."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"atom_labels"),": List of atom numbers used for generation of node features.")),(0,i.kt)("h5",{id:"example-14"},"Example"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"from jaqpotpy.descriptors.molecular import MolGanFeaturizer\nfrom rdkit import Chem\n\nsmiles = ['c1cc(O)ccc1']\nmol_object = Chem.MolFromSmiles('CCC')\nmolecules = [smiles, mol_object]\ngan_featurizer = MolGanFeaturizer()\n\ngan_features = gan_featurizer.featurize(molecules)\n\ngan_features[0].node_features\ngan_features[0].adjacency_matrix\n")))}c.isMDXComponent=!0}}]);